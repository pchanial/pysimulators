module operators

    use module_pointingmatrix
    implicit none

contains

    ! <itype=4,4,8,8>
    ! <mtype=4,8,4,8>

    subroutine fsr_kernel_i<itype>_m<mtype>(matrix, kernel, ncolmax, m, n)
        integer, parameter          :: s = <itype> + <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: m
        integer*8, intent(in)       :: n
        !f2py integer*1, intent(in) :: matrix(ncolmax*m*s)
        type(PointingElement_i<itype>_m<mtype>), intent(in) ::                 &
            matrix(ncolmax, m)
        logical(1), intent(inout)   :: kernel(0:n-1)
        integer*<itype> :: col
        integer*8 :: i, j        

        !$omp parallel do private(col)
        do i = 1, m
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0 .or. matrix(j,i)%value == 0) cycle
                kernel(col) = .false.
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_rot3d_kernel_i<itype>_m<mtype>(matrix, kernel, ncolmax, m, n)
        integer, parameter          :: s = <itype> + 3 * <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: m
        integer*8, intent(in)       :: n
        !f2py integer*1, intent(in) :: matrix(ncolmax*m*s)
        type(PointingElementRot3d_i<itype>_m<mtype>), intent(in) ::            &
            matrix(ncolmax, m)
        logical(1), intent(inout)   :: kernel(0:n-1)
        integer*<itype> :: col
        integer*8 :: i, j

        !$omp parallel do private(col)
        do i = 1, m
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0 .or. matrix(j,i)%r11 == 0) cycle
                kernel(col) = .false.
            end do
        end do
        !$omp end parallel do

    end subroutine


    ! <itype=4,4,4,8,8,8>
    ! <mtype=4,4,8,4,4,8>
    ! <vtype=4,8,8,4,8,8>

    subroutine fsr_pT1_i<itype>_m<mtype>_v<vtype>(matrix, pT1, ncolmax, ninput,&
                                    noutput)
        integer, parameter          :: s = <itype> + <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: ninput
        integer*8, intent(in)       :: noutput
        !f2py integer*1, intent(in) :: matrix(ncolmax*ninput*s)
        type(PointingElement_i<itype>_m<mtype>), intent(in) ::                 &
            matrix(ncolmax, ninput)
        real*<vtype>, intent(inout) :: pT1(0:noutput-1)
        integer*<itype> :: col
        integer*8 :: i, j        

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                !$omp atomic
                pT1(col) = pT1(col) + matrix(j,i)%value
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_rot3d_pT1_i<itype>_m<mtype>_v<vtype>(matrix, pT1, ncolmax,  &
                                          ninput, noutput)
        integer, parameter          :: s = <itype> + 3 * <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: ninput
        integer*8, intent(in)       :: noutput
        !f2py integer*1, intent(in) :: matrix(ncolmax*ninput*s)
        type(PointingElementRot3d_i<itype>_m<mtype>), intent(in) ::            &
            matrix(ncolmax, ninput)
        real*<vtype>, intent(inout) :: pT1(0:noutput-1)
        integer*<itype> :: col
        integer*8 :: i, j

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                !$omp atomic
                pT1(col) = pT1(col) + matrix(j,i)%r11
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_pTx_pT1_i<itype>_m<mtype>_v<vtype>(matrix, input, pTx, pT1, &
                                    ncolmax, ninput, noutput)
        integer, parameter          :: s = <itype> + <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: ninput
        integer*8, intent(in)       :: noutput
        !f2py integer*1, intent(in) :: matrix(ncolmax*ninput*s)
        type(PointingElement_i<itype>_m<mtype>), intent(in) ::                 &
            matrix(ncolmax, ninput)
        real*<vtype>, intent(in)    :: input(ninput)
        real*<vtype>, intent(inout) :: pTx(0:noutput-1)
        real*<vtype>, intent(inout) :: pT1(0:noutput-1)
        real*<mtype> :: val
        integer*<itype> :: col
        integer*8 :: i, j        

        !$omp parallel do private(col, val)
        do i = 1, ninput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                val = matrix(j,i)%value
                !$omp atomic
                pTx(col) = pTx(col) + val * input(i)
                !$omp atomic
                pT1(col) = pT1(col) + val
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_rot3d_pTx_pT1_i<itype>_m<mtype>_v<vtype>(matrix, input, pTx,&
                                          pT1, ncolmax, ninput, noutput)
        integer, parameter          :: s = <itype> + 3 * <mtype>
        integer*8, intent(in)       :: ncolmax
        integer*8, intent(in)       :: ninput
        integer*8, intent(in)       :: noutput
        !f2py integer*1, intent(in) :: matrix(ncolmax*ninput*s)
        type(PointingElementRot3d_i<itype>_m<mtype>), intent(in) ::            &
            matrix(ncolmax, ninput)
        real*<vtype>, intent(in)    :: input(ninput)
        real*<vtype>, intent(inout) :: pTx(0:noutput-1)
        real*<vtype>, intent(inout) :: pT1(0:noutput-1)
        real*<mtype> :: val
        integer*<itype> :: col
        integer*8 :: i, j

        !$omp parallel do private(col, val)
        do i = 1, ninput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                val = matrix(j,i)%r11
                !$omp atomic
                pTx(col) = pTx(col) + val * input(i)
                !$omp atomic
                pT1(col) = pT1(col) + val
            end do
        end do
        !$omp end parallel do

    end subroutine


end module operators
