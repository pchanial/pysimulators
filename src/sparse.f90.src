module sparse

    use, intrinsic :: iso_fortran_env, only : int32, int64, real32, real64
    use module_pointingmatrix
    implicit none

contains


    ! <ikind=int32,int32,int32,int64,int64,int64>
    ! <isize=4,4,4,8,8,8>
    ! <rkind=real32,real32,real64,real32,real32,real64>
    ! <rsize=4,4,8,4,4,8>
    ! <vkind=real32,real64,real64,real32,real64,real64>
    ! <vsize=4,8,8,4,8,8>

    subroutine fsc_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input, output,    &
                                   nrowmax, ninput, noutput)
        integer, parameter           :: s = <isize> + <rsize>
        integer(int64), intent(in)   :: nrowmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(nrowmax*s*ninput)
        type(PointingElement_i<isize>_r<rsize>), intent(in) ::                 &
            matrix(nrowmax, ninput)
        real(<vkind>), intent(in)    :: input(ninput)
        real(<vkind>), intent(inout) :: output(0:noutput-1)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        if (nrowmax == 1) then
            !$omp parallel do private(col)
            do i = 1, ninput
                col = matrix(1,i)%index
                if (col < 0) cycle
                !$omp atomic
                output(col) = output(col) + matrix(1,i)%value * input(i)
            end do
            !$omp end parallel do
            return
        end if

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, nrowmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                !$omp atomic
                output(col) = output(col) + matrix(j,i)%value * input(i)
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsc_nd_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input, output, &
                                      nrowmax, ninput, noutput, block_size)
        integer, parameter           :: s = <isize> + <rsize>
        integer(int64), intent(in)   :: nrowmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        integer(int64), intent(in)   :: block_size
        !f2py integer*1, intent(in)  :: matrix(nrowmax*s*ninput)
        type(PointingElement_i<isize>_r<rsize>), intent(in) ::                 &
            matrix(nrowmax, ninput)
        !f2py real(<vkind>)          :: input(block_size*ninput)
        real(<vkind>), intent(in)    :: input(block_size, ninput)
        !f2py real(<vkind>)          :: output(block_size*noutput)
        real(<vkind>), intent(inout) :: output(block_size, 0:noutput-1)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        if (nrowmax == 1) then
            !$omp parallel do private(col)
            do i = 1, ninput
                col = matrix(1,i)%index
                if (col < 0) cycle
                !$omp critical
                output(:,col) = output(:,col) + matrix(1,i)%value * input(:,i)
                !$omp end critical
            end do
            !$omp end parallel do
            return
        end if

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, nrowmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                !$omp critical
                output(:,col) = output(:,col) + matrix(j,i)%value * input(:,i)
                !$omp end critical
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsc_rot2d_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input,      &
                                         output, nrowmax, ninput, noutput)
        integer, parameter           :: s = <isize> + 2 * <rsize>
        integer(int64), intent(in)   :: nrowmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(nrowmax*s*ninput)
        type(PointingElementRot2d_i<isize>_r<rsize>), intent(in) ::            &
            matrix(nrowmax, ninput)
        !f2py real(<vkind>)          :: input(2*ninput)
        real(<vkind>), intent(in)    :: input(2,ninput)
        !f2py real(<vkind>)          :: output(2*noutput)
        real(<vkind>), intent(inout) :: output(2,0:noutput-1)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, nrowmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                 !$omp atomic
                output(1,col) = output(1,col) + (matrix(j,i)%r11 * input(1,i) +&
                                                 matrix(j,i)%r21 * input(2,i))
                !$omp atomic
                output(2,col) = output(2,col) + (-matrix(j,i)%r21 * input(1,i)+&
                                                  matrix(j,i)%r11 * input(2,i))
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsc_rot3d_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input,      &
                                         output, nrowmax, ninput, noutput)
        integer, parameter           :: s = <isize> + 3 * <rsize>
        integer(int64), intent(in)   :: nrowmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(nrowmax*s*ninput)
        type(PointingElementRot3d_i<isize>_r<rsize>), intent(in) ::            &
            matrix(nrowmax, ninput)
        !f2py real(<vkind>)          :: input(3*ninput)
        real(<vkind>), intent(in)    :: input(3,ninput)
        !f2py real(<vkind>)          :: output(3*noutput)
        real(<vkind>), intent(inout) :: output(3,0:noutput-1)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        !$omp parallel do private(col)
        do i = 1, ninput
            do j = 1, nrowmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                !$omp atomic
                output(1,col) = output(1,col) + matrix(j,i)%r11 * input(1,i)
                !$omp atomic
                output(2,col) = output(2,col) + (matrix(j,i)%r22 * input(2,i) +&
                                                 matrix(j,i)%r32 * input(3,i))
                !$omp atomic
                output(3,col) = output(3,col) + (-matrix(j,i)%r32 * input(2,i)+&
                                                  matrix(j,i)%r22 * input(3,i))
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input, output,    &
                                   ncolmax, ninput, noutput)
        integer, parameter           :: s = <isize> + <rsize>
        integer(int64), intent(in)   :: ncolmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(ncolmax*s*noutput)
        type(PointingElement_i<isize>_r<rsize>), intent(in) ::                 &
            matrix(ncolmax, noutput)
        real(<vkind>), intent(in)    :: input(0:ninput-1)
        real(<vkind>), intent(inout) :: output(noutput)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        if (ncolmax == 1) then
            !$omp parallel do private(col)
            do i = 1, noutput
                col = matrix(1,i)%index
                if (col < 0) cycle
                output(i) = output(i) + matrix(1,i)%value * input(col)
            end do
            !$omp end parallel do
            return
        end if

        !$omp parallel do private(col)
        do i = 1, noutput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                output(i) = output(i) + matrix(j,i)%value * input(col)
            end do
!!$         output(i) = output(i) +                                            &
!!$                     sum(input(matrix(:,i)%index) * matrix(:,i)%value,      &
!!$                         mask=matrix(:,i)%index >= 0)
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_nd_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input, output, &
                                      ncolmax, ninput, noutput, block_size)
        integer, parameter           :: s = <isize> + <rsize>
        integer(int64), intent(in)   :: ncolmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        integer(int64), intent(in)   :: block_size
        !f2py integer*1, intent(in)  :: matrix(ncolmax*s*noutput)
        type(PointingElement_i<isize>_r<rsize>), intent(in) ::                 &
            matrix(ncolmax, noutput)
        !f2py real(<vkind>)          :: input(block_size*ninput)
        real(<vkind>), intent(in)    :: input(block_size, 0:ninput-1)
        !f2py real(<vkind>)          :: output(block_size*noutput)
        real(<vkind>), intent(inout) :: output(block_size, noutput)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        if (ncolmax == 1) then
            !$omp parallel do private(col)
            do i = 1, noutput
                col = matrix(1,i)%index
                if (col < 0) cycle
                output(:,i) = output(:,i) + matrix(1,i)%value * input(:,col)
            end do
            !$omp end parallel do
            return
        end if

        !$omp parallel do private(col)
        do i = 1, noutput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                output(:,i) = output(:,i) + matrix(j,i)%value * input(:,col)
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_rot2d_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input,      &
                                         output, ncolmax, ninput, noutput)
        integer, parameter           :: s = <isize> + 2 * <rsize>
        integer(int64), intent(in)   :: ncolmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(ncolmax*s*noutput)
        type(PointingElementRot2d_i<isize>_r<rsize>), intent(in) ::            &
            matrix(ncolmax, noutput)
        !f2py real(<vkind>)          :: input(2*ninput)
        real(<vkind>), intent(in)    :: input(2,0:ninput-1)
        !f2py real(<vkind>)          :: output(2*noutput)
        real(<vkind>), intent(inout) :: output(2,noutput)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        !$omp parallel do private(col)
        do i = 1, noutput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                output(1,i) = output(1,i) + matrix(j,i)%r11 * input(1,col) -   &
                                            matrix(j,i)%r21 * input(2,col)
                output(2,i) = output(2,i) + matrix(j,i)%r21 * input(1,col) +   &
                                            matrix(j,i)%r11 * input(2,col)
            end do
        end do
        !$omp end parallel do

    end subroutine


    subroutine fsr_rot3d_matvec_i<isize>_r<rsize>_v<vsize>(matrix, input,      &
                                         output, ncolmax, ninput, noutput)
        integer, parameter           :: s = <isize> + 3 * <rsize>
        integer(int64), intent(in)   :: ncolmax
        integer(int64), intent(in)   :: ninput
        integer(int64), intent(in)   :: noutput
        !f2py integer*1, intent(in)  :: matrix(ncolmax*s*noutput)
        type(PointingElementRot3d_i<isize>_r<rsize>), intent(in) ::            &
            matrix(ncolmax, noutput)
        !f2py real(<vkind>)          :: input(3*ninput)
        real(<vkind>), intent(in)    :: input(3,0:ninput-1)
        !f2py real(<vkind>)          :: output(3*noutput)
        real(<vkind>), intent(inout) :: output(3,noutput)

        integer(int64) :: i, j
        integer(<ikind>) :: col

        !$omp parallel do private(col)
        do i = 1, noutput
            do j = 1, ncolmax
                col = matrix(j,i)%index
                if (col < 0) cycle
                output(1,i) = output(1,i) + matrix(j,i)%r11 * input(1,col)
                output(2,i) = output(2,i) + matrix(j,i)%r22 * input(2,col) -   &
                                            matrix(j,i)%r32 * input(3,col)
                output(3,i) = output(3,i) + matrix(j,i)%r32 * input(2,col) +   &
                                            matrix(j,i)%r22 * input(3,col)
            end do
        end do
        !$omp end parallel do

    end subroutine


end module sparse
