module module_math

    use, intrinsic :: iso_fortran_env, only :                                  &
        int32, int64, real32, real64, real128
    implicit none

    real(real32), parameter :: NAN_4  = transfer('FFFFFFFF'z, 0._real32)
    real(real32), parameter :: MINF_4 = transfer('FF700000'z, 0._real32)
    real(real32), parameter :: PINF_4 = transfer('7F700000'z, 0._real32)
    real(real32), parameter :: PI_4 = 4._real32 * atan(1._real32)
    real(real64), parameter :: NAN_8  = transfer('FFFFFFFFFFFFFFFF'z, 0._real64)
    real(real64), parameter :: MINF_8 = transfer('FFF0000000000000'z, 0._real64)
    real(real64), parameter :: PINF_8 = transfer('7FF0000000000000'z, 0._real64)
    real(real64), parameter :: PI_8 = 4._real64 * atan(1._real64)
#if PRECISION_REAL == 16
    real(real128), parameter :: NAN_16  =                                      &
        transfer('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'z, 0._real128)
    real(real128), parameter :: MINF_16 =                                      &
        transfer('FFFF0000000000000000000000000000'z, 0._real128)
    real(real128), parameter :: PINF_16 =                                      &
        transfer('7FFF0000000000000000000000000000'z, 0._real128)
    real(real128), parameter :: PI_16 = 4._real128 * atan(1._real128)
#endif

contains

    ! <ikind=int32,int32,int64,int64>
    ! <isize=4,4,8,8>
    ! <rkind=real32,real64,real32,real64>
    ! <rsize=4,8,4,8>

    elemental function round_htmi_i<isize>_r<rsize>(x) result(y)
        real(<rkind>), intent(in) :: x
        integer(<ikind>)          :: y
        y = ceiling(x - 0.5_<rkind>, <ikind>)
    end function


    !---------------------------------------------------------------------------


    elemental function round_htpi_i<isize>_r<rsize>(x) result(y)
        real(<rkind>), intent(in) :: x
        integer(<ikind>)          :: y
        y = floor(x + 0.5_<rkind>, <ikind>)
    end function

end module module_math
